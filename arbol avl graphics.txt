#include<iostream> 
	#include<string.h> 
	#include "graphics.h" 
	
	#include <math.h> 
	#include <stdlib.h> 
	#include <ctype.h> 
	using namespace std; 
	
	
	struct Node 
	{ //valor 
	int valor; 
	//nodos hijos 
	//se usaron, a diferencia del arreglo sides[1] para los punteros, 
	//dos punteros: izquierda y derecha 
	Node* izquierda; 
	Node* derecha; 
	//a diferencia del arbol binario anterior, necesitamos la altura del arbol 
	//puesto que vamos a balancear constantemente 
	int altura; 
	}; 
	
	
	class AvlBT 
	{ //raiz 
	Node* root; 
	//borra todo el arbol 
	void makeEmpty(Node* t) 
	{ 
	if (t == NULL) 
	return; 
	makeEmpty(t->izquierda); 
	makeEmpty(t->derecha); 
	delete t; 
	} 
	//insertar 
	Node* insert(int x, Node* t) //insert(numero, raiz) 
	{ //si el arbol esta vacio 
	if (t == nullptr) 
	{ //se crea nuevo nodo 
	t = new Node; 
	//se asigna el valor del nodo 
	t->valor = x; 
	//la altura de la raiz es 0 (como se vio en clase) 
	t->altura = 0; 
	//los hijos son null 
	t->izquierda = t->derecha = nullptr; 
	} 
	else if (x < t->valor) 
	{ 
	t->izquierda = insert(x, t->izquierda); 
	if (height(t->izquierda) - height(t->derecha) == 2) 
	{ 
	if (x < t->izquierda->valor) 
	t = RotacionDerechaSimple(t); 
	else 
	t = RotacionDerechaDoble(t); 
	} 
	} 
	else if (x > t->valor) 
	{ 
	t->derecha = insert(x, t->derecha); 
	if (height(t->derecha) - height(t->izquierda) == 2) 
	{ 
	if (x > t->derecha->valor) 
	t = RotacionIzquierdaSimple(t); 
	else 
	t = RotacionIzquierdaDoble(t); 
	} 
	} 
	
	t->altura = max(height(t->izquierda), height(t->derecha)) + 1; 
	return t; 
	} 
	
	Node* RotacionDerechaSimple(Node*& t) 
	{ 
	Node* u = t->izquierda; 
	t->izquierda = u->derecha; 
	u->derecha = t; 
	t->altura = max(height(t->izquierda), height(t->derecha)) + 1; 
	u->altura = max(height(u->izquierda), t->altura) + 1; 
	return u; 
	} 
	
	Node* RotacionIzquierdaSimple(Node*& t) 
	{ 
	Node* u = t->derecha; 
	t->derecha = u->izquierda; 
	u->izquierda = t; 
	t->altura = max(height(t->izquierda), height(t->derecha)) + 1; 
	u->altura = max(height(t->derecha), t->altura) + 1; 
	return u; 
	} 
	
	Node* RotacionIzquierdaDoble(Node*& t) 
	{ 
	t->derecha = RotacionDerechaSimple(t->derecha); 
	return RotacionIzquierdaSimple(t); 
	} 
	
	Node* RotacionDerechaDoble(Node*& t) 
	{ 
	t->izquierda = RotacionIzquierdaSimple(t->izquierda); 
	return RotacionDerechaSimple(t); 
	} 
	
	Node* encontrarMinimo(Node* t) 
	{ 
	if (t == NULL) 
	return NULL; 
	else if (t->izquierda == NULL) 
	return t; 
	else 
	return encontrarMinimo(t->izquierda); 
	} 
	
	Node* encontrarMaximo(Node* t) 
	{ 
	if (t == NULL) 
	return NULL; 
	else if (t->derecha == NULL) 
	return t; 
	else 
	return encontrarMaximo(t->derecha); 
	} 
	
	Node* remove(int x, Node* t) 
	{ 
	Node* temp; 
	
	if (t == NULL) 
	return NULL; 
	
	else if (x < t->valor) 
	t->izquierda = remove(x, t->izquierda); 
	else if (x > t->valor) 
	t->derecha = remove(x, t->derecha); 
	
	else if (t->izquierda && t->derecha) 
	{ 
	temp = encontrarMinimo(t->derecha); 
	t->valor = temp->valor; 
	t->derecha = remove(t->valor, t->derecha); 
	} 
	else 
	{ 
	temp = t; 
	if (t->izquierda == NULL) 
	t = t->derecha; 
	else if (t->derecha == NULL) 
	t = t->izquierda; 
	delete temp; 
	} 
	if (t == NULL) 
	return t; 
	
	t->altura = max(height(t->izquierda), height(t->derecha)) + 1; 
	
	if (height(t->izquierda) - height(t->derecha) == 2) 
	{ 
	if (t && height(t->izquierda->izquierda) - height(t->izquierda->derecha) == 1) 
	return RotacionIzquierdaSimple(t); 
	else 
	return RotacionIzquierdaDoble(t); 
	} 
	else if (height(t->derecha) - height(t->izquierda) == 2) 
	{ 
	if (t && height(t->derecha->derecha) - height(t->derecha->izquierda) == 1) 
	return RotacionDerechaSimple(t); 
	else 
	return RotacionDerechaDoble(t); 
	} 
	return t; 
	} 
	
	int height(Node* t) 
	{ 
	return (t == NULL ? -1 : t->altura); 
	} 
	
	int obtenerBalance(Node* t) 
	{ 
	if (t == NULL) 
	return 0; 
	else 
	return height(t->izquierda) - height(t->derecha); 
	} 
	
	void inorder(Node* t) 
	{ 
	if (t == NULL) 
	return; 
	inorder(t->izquierda); 
	cout << t->valor << " "; 
	inorder(t->derecha); 
	} 
	
	public: 
	AvlBT() 
	{ 
	root = NULL; 
	} 
	
	void insert(int x) 
	{ 
	root = insert(x, root); 
	} 
	
	void remove(int x) 
	{ 
	root = remove(x, root); 
	} 
	
	void printHelper(Node* root, string indent, bool last) { 
	if (root != nullptr) { 
	cout << indent; 
	if (last) { 
	cout << "R----"; 
	indent += " "; 
	} 
	else { 
	cout << "L----"; 
	indent += "| "; 
	} 
	cout << root->valor << endl; 
	printHelper(root->izquierda, indent, false); 
	printHelper(root->derecha, indent, true); 
	} 
	} 
	void imprimirArbol() 
	{ 
	if (root) { 
	printHelper(this->root, "", true); 
	} 
	} 
	
	Node* get_root() { 
	return this->root; 
	} 
	}; 
	
	
	void contador(int& cont2, Node* x) { 
	if (!x) return; 
	cont2 = cont2 + 1; 
	contador(cont2, x->izquierda); 
	contador(cont2, x->derecha); 
	} 
	
	void imprime(int x, int y, int opcion, Node* cab) { 
	if (!cab) return; 
	int contt = 0; 
	int x2 = x; 
	if (opcion == 0) { 
	contador(contt, cab->derecha); 
	x = x - (contt * 60) - 60; 
	} 
	else if (opcion == 1) { 
	contador(contt, cab->izquierda); 
	x = x + (contt * 60) + 60; 
	} 
	char buffer[5]; 
	strcpy(buffer, to_string(cab->valor).c_str()); 
	circle(x, y, 30); 
	settextstyle(ARW_STARTRIGHT, 0, 3); 
	outtextxy(x - 15, y - 15, buffer); 
	line(x2, y - 90, x, y - 30); 
	
	imprime(x, y + 120, 0, cab->izquierda); 
	imprime(x, y + 120, 1, cab->derecha); 
	} 
	
	int main() { 
	AvlBT bt; 
	
	
	int choice; 
	//dibujo inicial vacio 
	initwindow(1200, 800, "Avl BTree"); 
	
	do { 
	cout << "\n\n--------Menu-----------\n"; 
	cout << "1.Insertar\n"; 
	cout << "2.Eliminar\n"; 
	cout << "3. Mostrar\n"; 
	cout << "4.Salir\n-----------------------"; 
	cout << "\nHola, ingresa tu opcion(1,2,3,4):\t"; 
	cin >> choice; 
	switch (choice) 
	{ 
	case 1: { 
	
	int a; 
	cout << "\nIngresa el numero a insertar:\t"; 
	cin >> a; 
	bt.insert(a); 
	cleardevice(); 
	
	int x = 0; 
	contador(x, bt.get_root()); //ubica el arbol en un plano cartesiano 
	imprime(x * 40, 100, 3, bt.get_root()); 
	
	system("pause"); 
	
	
	break; 
	} 
	case 2: 
	
	int b; 
	cout << "\nIngresa el numero a eliminar:\t"; 
	cin >> b; 
	if (bt.get_root() != nullptr) { 
	bt.remove(b); 
	cleardevice(); 
	
	int x = 0; 
	
	
	
	contador(x, bt.get_root()); 
	imprime(x * 40, 100, 3, bt.get_root()); 
	
	system("pause"); 
	
	
	} 
	
	
	break; 
	
	case 3: 
	{ cleardevice(); 
	
	//mostrar grafico 
	int x = 0; 
	
	
	contador(x, bt.get_root()); 
	imprime(x * 40, 100, 3, bt.get_root()); 
	//mostrar en consola: 
	
	bt.imprimirArbol(); 
	
	break; 
	} 
	case 4: { 
	
	break; 
	
	} 
	default:cout << "\nInvalido\n"; 
	} 
	//bt.toDot("Queue.dot"); 
	//system("dot Queue.dot -Tsvg -o Queue.svg"); 
	
	} while (choice != 4); 
	
	/* 
	bt.insert(10); 
	bt.insert(30); 
	bt.insert(5); 
	bt.imprimirArbol(); 
	*/ 
	
	/* 
	initwindow(1200, 800, "Avl BTree"); 
	int x = 0; 
	contador(x, bt.get_root()); 
	imprime(x * 40, 100, 3, bt.get_root()); 
	*/ 
	
	system("pause"); 
	/* 
	cleardevice(); 
	bt.remove(5); 
	bt.remove(35); 
	bt.remove(65); 
	bt.remove(89); 
	bt.remove(43); 
	bt.remove(88); 
	bt.remove(20); 
	bt.remove(38); 
	bt.imprimirArbol(); 
	*/ 
	return 0; 
	} 
	
	/*output: 
	| L----21 
	R----43 
	L----35 
	| R----38 
	R----69 
	L----67 
	R----89 
	Presione una tecla para continuar . . . 
	R----30 
	L----21 
	| L----10 
	| | R----15 
	| R----25 
	R----67 
	R----69 
	Presione una tecla para continuar . . . 
	*/
